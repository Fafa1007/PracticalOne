# Practical Two

## Generate Simulated Data:

Set your seed to 1, i.e.Â `set.seed(1)`.

```{r}
set.seed(1)
```

Create $x$ as a sequence of numbers from 1 to 100.

```{r}
x <- 1:100
```

Generate $y$ as a noisy sine wave such that $y_i = sin(\frac{x_i}{10}) +e_i$ where $e_i \sim N(0, 0.2^2)$

```{r}
y <- numeric(100)
for (i in 1:100 ){
  y[i] <- rnorm(1, mean=0, sd = 0.2)
}
```

```{r}
# Define the span f which defines the number of closest neighbours to use when smoothing point xi
f <- as.numeric(readline("Enter a value for f (between 0 and 1): "))
```

------------------------------------------------------------------------

## Implement the LOWESS Algorithm:

Define a function `customLowess(x, y, f)` that returns the smoothed values

```{r}
customLowess<- function(x,y,f){
  k = f*length(x) # k is the number of closest neighbours used for point xi
  
  # Finding dmax
  dmax <- 0
  for (i in 1:k){
    for (j in 1:k){
      if (dmax < abs(x[i]-x[j])){
        #print(paste("x[i]=", x[i], " x[j]=", x[j]))
        dmax <- x[i] - x[j]
      }
    }
  }
  
  # Computing Weights
  w <- matrix(nrow=k, ncol=k)
  for(i in 1:k){
    for(j in 1: k)
    w[i][j] <- (1-(abs(x[i]-x[j])/dmax)^3)^3
  }
  x[1][1] <- 1
}
```

```{r}
# Function to find the weights
lowess_weights <- function(x_target, x_neighbors, d_max) {
  # Compute the absolute distances between the target and neighbors
  distances <- abs(x_target - x_neighbors)
  
  # Calculate the weights using the tricubic formula
  weights <- (1 - (distances / d_max)^3)^3
  weights[distances > d_max] <- 0  # No weight for points farther than d_max
  return(weights)
}

# Function to find the Beta Coefficients to perform the weighted linear regression
lowess_beta <- function(x, y, w ){
  
}

# Function to perform LOWESS smoothing
lowess_smoothing <- function(x, y, f) {
  n <- length(x)
  k <- ceiling(f * n)  # Number of neighbors based on the span
  smoothed_y <- numeric(n)
  
  for (i in 1:n) {
    # Find the k closest neighbors for each point
    distances <- abs(x[i] - x)
    neighbor_indices <- order(distances)[1:k] # gets the largest k distances
    x_neighbors <- x[neighbor_indices]
    
    # Compute d_max (max distance between the target and neighbors)
    d_max <- max(distances[neighbor_indices])
    
    # Compute the weights for the neighbors
    weights <- lowess_weights(x[i], x_neighbors, d_max)
    
  }
  
  return(smoothed_y)
}

# User input for the span f (between 0 and 1)
f <- as.numeric(readline("Enter a value for f (between 0 and 1): "))

# Apply LOWESS smoothing
smoothed_y <- lowess_smoothing(x, y, f)
```

------------------------------------------------------------------------

## Compare with R's Built-in lowess()

Use the built-in `lowess()` function with the same `f` value. You will also need to set the `iter` argument to 0.

```{r}
lowess(x, y, f)
```

Plot both curves to compare their smoothing values.

```{r}

```
